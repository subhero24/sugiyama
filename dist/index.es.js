const FORCE=.1;let ancestors=node=>{if(null!=node.ancestors)return node.ancestors;node.ancestors=[];for(let parent of node.parents)if(!node.ancestors.includes(parent)){node.ancestors.push(parent);for(let ancestor of ancestors(parent))node.ancestors.includes(ancestor)||node.ancestors.push(ancestor)}return node.ancestors},descendents=node=>{if(null!=node.descendents)return node.descendents;node.descendents=[];for(let child of node.children)if(!node.descendents.includes(child)){node.descendents.push(child);for(let descendent of descendents(child))node.descendents.includes(descendent)||node.descendents.push(descendent)}return node.descendents};function shouldSwap(edges1,edges2){let balance=0;for(let i=0;i<edges1.length;++i)for(let j=i;j<edges2.length;++j)balance+=Math.sign(edges1[i]-edges2[j]);return balance>0}export default function(nodes,fns){let{childrenFunc:childrenFunc,parentFunc:parentFunc,dummyFunc:dummyFunc,width:width,height:height,margin:margin,iterations:iterations}=fns,graph=function(nodes,fns){let{childFunc:childFunc,parentFunc:parentFunc}=fns;if(null==childFunc&&null==parentFunc)throw new Error("Could not create topology without childFunc or parentFunc");let topology=new Map;for(let key of nodes){let value={value:key,parents:[],children:[]};topology.set(key,value)}if(parentFunc&&childFunc);else{if(parentFunc){for(let[node,nodeT]of topology.entries()){let parents=parentFunc(node);if(null!=parents&&0!==parents.length)for(let parent of parents){let parentT=topology.get(parent);nodeT.parents.includes(parentT)||nodeT.parents.push(parentT),parentT.children.includes(nodeT)||parentT.children.push(nodeT)}}for(let nodeT of topology.values())ancestors(nodeT),descendents(nodeT);return topology}if(childFunc)throw new Error("childFunc not implemented")}}(nodes,{childrenFunc:childrenFunc,parentFunc:parentFunc});return function(graph){let nodes=graph.values();for(let node of nodes)for(let parent of node.parents)for(let parentsibling of node.parents)parentsibling!==parent&&parentsibling.ancestors.includes(parent)&&(node.parents.splice(node.parents.indexOf(parent),1),parent.children.splice(parent.children.indexOf(node),1))}(graph),function(graph){for(let node of graph.values())0===node.parents.length&&setLevel(node,0);function setLevel(node,level,skip=[]){node.level=level;for(let child of node.children)skip.includes(child)||(null==child.level||child.level<level+1)&&setLevel(child,level+1,[...skip,node]);for(let parent of node.parents)skip.includes(parent)||null==parent.level&&setLevel(parent,level-1,[...skip,node])}}(graph),function(graph,options={}){let{dummyFunc:dummyFunc}={dummyFunc:()=>({}),...options},nodes=graph.values();for(let parent of nodes)for(let child of parent.children){let distance=child.level-parent.level;if(distance>1){child.parents.splice(child.parents.indexOf(parent),1),parent.children.splice(parent.children.indexOf(child),1);let prev=parent;for(let i=0;i<distance-1;++i){let node={parents:[],children:[],level:parent.level+i+1,value:dummyFunc(i,parent,child)};graph.set(node.value,node),node.parents.push(prev),prev.children.push(node),prev=node}child.parents.push(prev),prev.children.push(child)}}}(graph,{dummyFunc:dummyFunc}),function(graph){let nodes=Array.from(graph.values()),level=0,previous=nodes.filter(n=>0===n.level);for(let[index,node]of previous.entries())node.order=index;for(;;){level++;let layer=nodes.filter(n=>n.level===level);if(0===layer.length)break;if(1===layer.length){layer[0].order=0;continue}let order=new Map;for(let node of layer){let avg=node.parents.reduce((s,p)=>s+=p.order,0)/node.parents.length;order.set(node,avg)}let edges=new Map;for(let node of layer)edges.set(node,node.parents.map(p=>previous.indexOf(p)));layer=layer.sort((a,b)=>order.get(a)-order.get(b));let finished=!1;for(;!finished;){finished=!0;for(let i=0;i<=layer.length-2;++i)shouldSwap(edges.get(layer[i]),edges.get(layer[i+1]))&&(finished=!1,[layer[i],layer[i+1]]=[layer[i+1],layer[i]])}for(let[index,node]of layer.entries())node.order=index;previous=layer}}(graph),function(graph,options={}){let{width:width,height:height,margin:margin,iterations:iterations}=options;null==width&&(width=0),null==height&&(height=0),null==margin&&(margin=1),null==iterations&&(iterations=100);let dimensions=new Map;for(let[key,value]of graph.entries())dimensions.set(value,{width:"function"==typeof width?width(key)||0:width,height:"function"==typeof height?height(key)||0:height});let nodes=Array.from(graph.values()),layers=[];for(let node of nodes)null==layers[node.level]&&(layers[node.level]=[]),layers[node.level].push(node);let x=margin;for(let level=0;level<layers.length;++level){let y=0,nodes=layers[level].sort((a,b)=>a.order-b.order),levelwidth=Math.max(...nodes.map(n=>dimensions.get(n).width));for(let node of layers[level]){let nodeheight=dimensions.get(node).height;node.x=x+levelwidth/2,node.y=y+nodeheight/2,y=y+nodeheight+margin}layers[level]=nodes,x=x+levelwidth+margin}let previous=new Map;for(let i=0;i<iterations;++i){let velocities=new Map;for(let node of nodes){let oldY=previous.get(node);null==oldY?velocities.set(node,0):velocities.set(node,node.y-oldY)}for(let node of nodes)previous.set(node,node.y);for(let level=0;level<layers.length;level++){let j,layer=layers[level],gradients=new Map;for(let node of layer){gradients.set(node,0);for(let neighbour of[...node.children,...node.parents]){let force=(previous.get(neighbour)-previous.get(node))*FORCE;gradients.set(node,gradients.get(node)+force)}}let blockIndex=0,blockBound=-1/0;for(j=0;j<layer.length;++j){let node=layer[j],height=dimensions.get(node).height,target=node.y+gradients.get(node),lowerbound=target-height/2,upperbound=target+height/2;if(0===j||lowerbound<blockBound)blockBound=Math.max(blockBound,blockBound+margin,upperbound+margin);else{let block=layer.slice(blockIndex,j),average=block.reduce((g,n)=>g+gradients.get(n),0)/block.length;for(let node of block)gradients.set(node,average);blockIndex=j,blockBound=upperbound+margin}}let block=layer.slice(blockIndex,j),average=block.reduce((g,n)=>g+gradients.get(n),0)/block.length;for(let node of block)gradients.set(node,average);for(let[node,gradient]of gradients)node.y+=gradient}}}(graph,{width:width,height:height,margin:margin,iterations:iterations}),function(graph){let nodes=Array.from(graph.values()),interval=nodes.reduce(([min,max],node)=>[Math.min(node.y,min),Math.max(node.y,max)],[nodes[0].y,nodes[0].y]),[minY,maxY]=interval,center=(maxY-minY)/2+minY;for(let node of nodes)node.y-=center}(graph),graph}
//# sourceMappingURL=index.es.js.map
