{"version":3,"file":"index.es.js","sources":["../src/balance.js","../src/topology.js","../src/calculate-order.js","../src/layout.js","../src/minimize.js","../src/calculate-level.js","../src/normalize.js","../src/shift.js"],"sourcesContent":["// Balance is an iterative method to adjust the position (but not order) to improve graph aesthetics\n\nconst FORCE = 0.1;\nconst MIN_DISTANCE = 1;\n\n// Limiting the max force is necessary because the constraint of the minimum distance\n// displaces siblings to account for this distance, which can increase spring lengths,\n// which can increase the force of the springs and make the solution unstable\n\nexport default function(graph, iterations = 100) {\n\tlet nodes = Array.from(graph.values());\n\tlet previous = new Map();\n\n\tfor (let node of nodes) {\n\t\tnode.y = node.order;\n\t\tnode.x = node.level;\n\t}\n\n\tfor (let i = 0; i < iterations; ++i) {\n\t\t// Calculate properties dependent on old coordinates, ie velocity\n\t\tlet velocities = new Map();\n\t\tfor (let node of nodes) {\n\t\t\tlet oldY = previous.get(node);\n\t\t\tif (oldY == undefined) {\n\t\t\t\tvelocities.set(node, 0);\n\t\t\t} else {\n\t\t\t\tvelocities.set(node, node.y - oldY);\n\t\t\t}\n\t\t}\n\n\t\t// Update old coordinates\n\t\tfor (let node of nodes) {\n\t\t\tprevious.set(node, node.y);\n\t\t}\n\n\t\t// Calculate layer node gradients\n\t\tlet x = 0;\n\t\twhile (true) {\n\t\t\tlet gradients = new Map();\n\n\t\t\tlet layer = nodes.filter(n => n.level === x).sort((a, b) => a.y - b.y);\n\t\t\tif (layer.length === 0) break;\n\n\t\t\tfor (let node of layer) {\n\t\t\t\t// Neighbouring child springs\n\t\t\t\tgradients.set(node, 0);\n\t\t\t\tfor (let neighbour of [...node.children, ...node.parents]) {\n\t\t\t\t\tlet force = (previous.get(neighbour) - previous.get(node)) * FORCE;\n\t\t\t\t\tgradients.set(node, gradients.get(node) + force);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet i;\n\t\t\tlet blockIndex = 0;\n\t\t\tlet blockBound = -Infinity;\n\t\t\tfor (i = 0; i < layer.length; ++i) {\n\t\t\t\tlet node = layer[i];\n\t\t\t\tlet target = node.y + gradients.get(node);\n\n\t\t\t\tif (i === 0 || target < blockBound) {\n\t\t\t\t\t// If the node's target is too close to the previous node, just continue grouping nodes\n\t\t\t\t\tblockBound = Math.max(blockBound, blockBound + MIN_DISTANCE, target + MIN_DISTANCE);\n\t\t\t\t} else {\n\t\t\t\t\t// If the node's target will be too far away to belongs to the group, group the previous nodes and start a new group\n\t\t\t\t\tlet block = layer.slice(blockIndex, i);\n\t\t\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t\t\tblockIndex = i;\n\t\t\t\t\tblockBound = target + MIN_DISTANCE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All the last nodes also form a group\n\t\t\tlet block = layer.slice(blockIndex, i);\n\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t// Translate all nodes with their calculated gradient\n\t\t\tfor (let [node, gradient] of gradients) node.y += gradient;\n\n\t\t\tx++;\n\t\t}\n\t}\n\n\treturn nodes;\n}\n","// Returns a map from the given nodes to an object that contains all the graph info\n\n// Calculates all ancestors of a node\nlet ancestors = node => {\n\t// Ancestors are already calculated\n\tif (node.ancestors != undefined) return node.ancestors;\n\n\t// Loop through all parents to add them as ancestors, and recursively add their ancestors too\n\tnode.ancestors = [];\n\tfor (let parent of node.parents) {\n\t\t// Check if the parent of this node was already added.\n\t\t// This only happens if the original nodes specified the same parent twice\n\t\tif (!node.ancestors.includes(parent)) {\n\t\t\tnode.ancestors.push(parent);\n\t\t\t// Find all ancestors of the parent and add them if necessary\n\t\t\tfor (let ancestor of ancestors(parent)) {\n\t\t\t\t// An ancestor could already be part of the ancestors if there was\n\t\t\t\t// another path in the graph leading to this ancestor\n\t\t\t\tif (!node.ancestors.includes(ancestor)) {\n\t\t\t\t\tnode.ancestors.push(ancestor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.ancestors;\n};\n\n// Calculates all descendents of a node\nlet descendents = node => {\n\t// Descendents are already calculated\n\tif (node.descendents != undefined) return node.descendents;\n\n\t// Loop through all children to add them as descendents, and recursively add their descendents too\n\tnode.descendents = [];\n\tfor (let child of node.children) {\n\t\t// Check if the child of this node was already added.\n\t\t// This only happens if the original nodes specified the same child twice\n\t\tif (!node.descendents.includes(child)) {\n\t\t\tnode.descendents.push(child);\n\t\t\t// Find all descendents of the child and add them if necessary\n\t\t\tfor (let descendent of descendents(child)) {\n\t\t\t\t// An descendent could already be part of the descendents if there was\n\t\t\t\t// another path in the graph leading to this descendent\n\t\t\t\tif (!node.descendents.includes(descendent)) {\n\t\t\t\t\tnode.descendents.push(descendent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.descendents;\n};\n\nexport default function(nodes, fns) {\n\tlet { childFunc, parentFunc } = fns;\n\n\tif (childFunc == undefined && parentFunc == undefined) {\n\t\tthrow new Error('Could not create topology without childFunc or parentFunc');\n\t}\n\n\t// Topology is a map linking the originial node with its corresponding graph information object\n\t// specifying parents, children, ancestors, descendents, position, ...\n\tlet topology = new Map();\n\tfor (let key of nodes) {\n\t\tlet value = {\n\t\t\tvalue: key,\n\t\t\tparents: [],\n\t\t\tchildren: [],\n\t\t};\n\n\t\ttopology.set(key, value);\n\t}\n\n\tif (parentFunc && childFunc) {\n\t\t// TODO: could use both funcs to calculate all relations in 1 iteration\n\t} else if (parentFunc) {\n\t\t// First we have to loop through all nodes as we can only go \"up\" the graph\n\t\t// and can therefore not know all children of a node while traversing it for the first time\n\n\t\tfor (let [node, nodeT] of topology.entries()) {\n\t\t\tlet parents = parentFunc(node);\n\t\t\tif (parents != undefined && parents.length !== 0) {\n\t\t\t\tfor (let parent of parents) {\n\t\t\t\t\tlet parentT = topology.get(parent);\n\t\t\t\t\tif (!nodeT.parents.includes(parentT)) nodeT.parents.push(parentT);\n\t\t\t\t\tif (!parentT.children.includes(nodeT)) parentT.children.push(nodeT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let nodeT of topology.values()) {\n\t\t\tancestors(nodeT);\n\t\t\tdescendents(nodeT);\n\t\t}\n\n\t\treturn topology;\n\t} else if (childFunc) {\n\t\t// TODO\n\t\tthrow new Error('childFunc not implemented');\n\t}\n}\n","// Assigns a vertical order of the nodes to minimize link crossings\n\nfunction shouldSwap(edges1, edges2) {\n\tlet balance = 0;\n\tfor (let i = 0; i < edges1.length; ++i) {\n\t\tfor (let j = i; j < edges2.length; ++j) {\n\t\t\tbalance += Math.sign(edges1[i] - edges2[j]);\n\t\t}\n\t}\n\treturn balance > 0;\n}\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\n\t// Start with orphans, and position them in order they are defined\n\tlet level = 0;\n\tlet previous = nodes.filter(n => n.level === 0);\n\tfor (let [index, node] of previous.entries()) {\n\t\tnode.order = index;\n\t}\n\n\twhile (true) {\n\t\tlevel++;\n\t\tlet layer = nodes.filter(n => n.level === level);\n\n\t\tif (layer.length === 0) break;\n\t\tif (layer.length === 1) {\n\t\t\tlayer[0].order = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//  Calculate all preferred node positions as average of parent positions\n\t\tlet order = new Map();\n\t\tfor (let node of layer) {\n\t\t\tlet sum = node.parents.reduce((s, p) => (s += p.order), 0);\n\t\t\tlet avg = sum / node.parents.length;\n\t\t\torder.set(node, avg);\n\t\t}\n\n\t\t// Calculate all parent edge arrays\n\t\tlet edges = new Map();\n\t\tfor (let node of layer) {\n\t\t\tedges.set(node, node.parents.map(p => previous.indexOf(p)));\n\t\t}\n\n\t\t// Sort the layer according to the calculated positions\n\t\tlayer = layer.sort((a, b) => order.get(a) - order.get(b));\n\n\t\t// Bubble sort the layer to minimize edge crossings\n\t\tlet finished = false;\n\t\twhile (!finished) {\n\t\t\tfinished = true;\n\t\t\tfor (let i = 0; i <= layer.length - 2; ++i) {\n\t\t\t\tlet edgesA = edges.get(layer[i]);\n\t\t\t\tlet edgesB = edges.get(layer[i + 1]);\n\t\t\t\tlet swap = shouldSwap(edgesA, edgesB);\n\t\t\t\tif (swap) {\n\t\t\t\t\tfinished = false;\n\t\t\t\t\t[layer[i], layer[i + 1]] = [layer[i + 1], layer[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let [index, node] of layer.entries()) {\n\t\t\tnode.order = index;\n\t\t}\n\n\t\tprevious = layer;\n\t}\n}\n","import shift from './shift';\nimport balance from './balance';\nimport topology from './topology';\nimport minimize from './minimize';\nimport normalize from './normalize';\nimport calculateOrder from './calculate-order';\nimport calculateLevel from './calculate-level';\n\nexport default function(nodes, fns) {\n\tlet { childrenFunc, parentFunc, dummyFunc } = fns;\n\n\tlet graph = topology(nodes, { childrenFunc, parentFunc });\n\n\tminimize(graph);\n\tcalculateLevel(graph);\n\tnormalize(graph, dummyFunc);\n\tcalculateOrder(graph);\n\tbalance(graph);\n\tshift(graph);\n\n\treturn graph;\n}\n","// This cleans up unnecessary edges which connects two nodes\n// that are already connected through intermediate nodes\nexport default function(graph) {\n\tlet nodes = graph.values();\n\tfor (let node of nodes) {\n\t\tfor (let parent of node.parents) {\n\t\t\tfor (let parentsibling of node.parents) {\n\t\t\t\tif (parentsibling === parent) continue;\n\t\t\t\tif (parentsibling.ancestors.includes(parent)) {\n\t\t\t\t\tnode.parents.splice(node.parents.indexOf(parent), 1);\n\t\t\t\t\tparent.children.splice(parent.children.indexOf(node), 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","// Assigns a level to all nodes depending on the horizontal order in the graph\n// A node moves it child nodes to a level + 1, parent nodes can not receive a levelup based on the level of it's child node.\nexport default function(graph) {\n\tfor (let node of graph.values()) {\n\t\tif (node.parents.length === 0) {\n\t\t\tsetLevel(node, 0);\n\t\t}\n\t}\n\n\tfunction setLevel(node, level, skip = []) {\n\t\tnode.level = level;\n\t\tfor (let child of node.children) {\n\t\t\tif (skip.includes(child)) continue;\n\t\t\tif (child.level == undefined || child.level < level + 1) {\n\t\t\t\tsetLevel(child, level + 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let parent of node.parents) {\n\t\t\tif (skip.includes(parent)) continue;\n\t\t\tif (parent.level == undefined) {\n\t\t\t\tsetLevel(parent, level - 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\t}\n}\n","// Normalize adds dummy nodes in the graph to avoid links spanning multiple levels\nexport default function(graph, dummyFunc = () => ({})) {\n\tlet nodes = graph.values();\n\n\tfor (let parent of nodes) {\n\t\tfor (let child of parent.children) {\n\t\t\tlet distance = child.level - parent.level;\n\t\t\tif (distance > 1) {\n\t\t\t\t// If node and child span multiple levels, remove the relation between the two\n\t\t\t\t// A new node will be inserted to represent the relation\n\t\t\t\tchild.parents.splice(child.parents.indexOf(parent), 1);\n\t\t\t\tparent.children.splice(parent.children.indexOf(child), 1);\n\n\t\t\t\t// Roll through all the levels and adding as many nodes as necessary to span the level difference\n\t\t\t\tlet prev = parent;\n\t\t\t\tfor (let i = 0; i < distance - 1; ++i) {\n\t\t\t\t\tlet node = {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tlevel: parent.level + i + 1,\n\t\t\t\t\t\tvalue: dummyFunc(i, parent, child),\n\t\t\t\t\t};\n\n\t\t\t\t\tgraph.set(node.value, node);\n\t\t\t\t\tnode.parents.push(prev);\n\t\t\t\t\tprev.children.push(node);\n\n\t\t\t\t\tprev = node;\n\t\t\t\t}\n\n\t\t\t\tchild.parents.push(prev);\n\t\t\t\tprev.children.push(child);\n\t\t\t}\n\t\t}\n\t}\n}\n","// Shifts all nodes to vertically center the graph around the node in the first layer (x = 0)\n// that is closest to the vertical center of the graph\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\tlet interval = nodes.reduce(\n\t\t([min, max], node) => {\n\t\t\treturn [Math.min(node.y, min), Math.max(node.y, max)];\n\t\t},\n\t\t[nodes[0].y, nodes[0].y],\n\t);\n\n\tlet [minY, maxY] = interval;\n\tlet center = (maxY - minY) / 2 + minY;\n\n\tfor (let node of nodes) node.y -= center;\n\n\treturn nodes;\n}\n"],"names":["FORCE","MIN_DISTANCE","ancestors","node","undefined","parent","parents","includes","push","ancestor","descendents","child","children","descendent","shouldSwap","edges1","edges2","balance","i","length","j","Math","sign","nodes","fns","childrenFunc","parentFunc","dummyFunc","graph","childFunc","Error","topology","Map","key","value","set","nodeT","entries","parentT","get","values","parentsibling","splice","indexOf","minimize","setLevel","level","skip","calculateLevel","distance","prev","normalize","Array","from","previous","filter","n","index","order","layer","avg","reduce","s","p","edges","map","sort","a","b","finished","calculateOrder","iterations","y","x","velocities","oldY","gradients","neighbour","force","blockIndex","blockBound","target","max","block","slice","average","g","gradient","interval","min","minY","maxY","center","shift"],"mappings":"AAEA,MAAMA,MAAQ,GACRC,aAAe,ECArB,IAAIC,UAAYC,UAEOC,MAAlBD,KAAKD,UAAwB,OAAOC,KAAKD,UAG7CC,KAAKD,UAAY,OACZ,IAAIG,UAAUF,KAAKG,YAGlBH,KAAKD,UAAUK,SAASF,QAAS,CACrCF,KAAKD,UAAUM,KAAKH,YAEf,IAAII,YAAYP,UAAUG,QAGzBF,KAAKD,UAAUK,SAASE,WAC5BN,KAAKD,UAAUM,KAAKC,iBAMjBN,KAAKD,WAITQ,YAAcP,UAEOC,MAApBD,KAAKO,YAA0B,OAAOP,KAAKO,YAG/CP,KAAKO,YAAc,OACd,IAAIC,SAASR,KAAKS,aAGjBT,KAAKO,YAAYH,SAASI,OAAQ,CACtCR,KAAKO,YAAYF,KAAKG,WAEjB,IAAIE,cAAcH,YAAYC,OAG7BR,KAAKO,YAAYH,SAASM,aAC9BV,KAAKO,YAAYF,KAAKK,mBAMnBV,KAAKO,aCjDb,SAASI,WAAWC,OAAQC,YACvBC,QAAU,MACT,IAAIC,EAAI,EAAGA,EAAIH,OAAOI,SAAUD,MAC/B,IAAIE,EAAIF,EAAGE,EAAIJ,OAAOG,SAAUC,EACpCH,SAAWI,KAAKC,KAAKP,OAAOG,GAAKF,OAAOI,WAGnCH,QAAU,iBCDH,SAASM,MAAOC,SAC1BC,aAAEA,aAAFC,WAAgBA,WAAhBC,UAA4BA,WAAcH,IAE1CI,MF2CU,SAASL,MAAOC,SAC1BK,UAAEA,UAAFH,WAAaA,YAAeF,OAEfpB,MAAbyB,WAAwCzB,MAAdsB,iBACvB,IAAII,MAAM,iEAKbC,SAAW,IAAIC,QACd,IAAIC,OAAOV,MAAO,KAClBW,MAAQ,CACXA,MAAOD,IACP3B,QAAS,GACTM,SAAU,IAGXmB,SAASI,IAAIF,IAAKC,UAGfR,YAAcG,eAEX,CAAA,GAAIH,WAAY,KAIjB,IAAKvB,KAAMiC,SAAUL,SAASM,UAAW,KACzC/B,QAAUoB,WAAWvB,SACVC,MAAXE,SAA2C,IAAnBA,QAAQa,WAC9B,IAAId,UAAUC,QAAS,KACvBgC,QAAUP,SAASQ,IAAIlC,QACtB+B,MAAM9B,QAAQC,SAAS+B,UAAUF,MAAM9B,QAAQE,KAAK8B,SACpDA,QAAQ1B,SAASL,SAAS6B,QAAQE,QAAQ1B,SAASJ,KAAK4B,YAK3D,IAAIA,SAASL,SAASS,SAC1BtC,UAAUkC,OACV1B,YAAY0B,cAGNL,SACD,GAAIF,gBAEJ,IAAIC,MAAM,8BExFLC,CAASR,MAAO,CAAEE,aAAAA,aAAcC,WAAAA,oBCT7C,SAAwBE,WACnBL,MAAQK,MAAMY,aACb,IAAIrC,QAAQoB,UACX,IAAIlB,UAAUF,KAAKG,YAClB,IAAImC,iBAAiBtC,KAAKG,QAC1BmC,gBAAkBpC,QAClBoC,cAAcvC,UAAUK,SAASF,UACpCF,KAAKG,QAAQoC,OAAOvC,KAAKG,QAAQqC,QAAQtC,QAAS,GAClDA,OAAOO,SAAS8B,OAAOrC,OAAOO,SAAS+B,QAAQxC,MAAO,IDG1DyC,CAAShB,OEXV,SAAwBA,WAClB,IAAIzB,QAAQyB,MAAMY,SACM,IAAxBrC,KAAKG,QAAQa,QAChB0B,SAAS1C,KAAM,YAIR0C,SAAS1C,KAAM2C,MAAOC,KAAO,IACrC5C,KAAK2C,MAAQA,UACR,IAAInC,SAASR,KAAKS,SAClBmC,KAAKxC,SAASI,SACCP,MAAfO,MAAMmC,OAAsBnC,MAAMmC,MAAQA,MAAQ,IACrDD,SAASlC,MAAOmC,MAAQ,EAAG,IAAIC,KAAM5C,WAIlC,IAAIE,UAAUF,KAAKG,QACnByC,KAAKxC,SAASF,SACED,MAAhBC,OAAOyC,OACVD,SAASxC,OAAQyC,MAAQ,EAAG,IAAIC,KAAM5C,QFPzC6C,CAAepB,OGbhB,SAAwBA,MAAOD,UAAY,gBACtCJ,MAAQK,MAAMY,aAEb,IAAInC,UAAUkB,UACb,IAAIZ,SAASN,OAAOO,SAAU,KAC9BqC,SAAWtC,MAAMmC,MAAQzC,OAAOyC,SAChCG,SAAW,EAAG,CAGjBtC,MAAML,QAAQoC,OAAO/B,MAAML,QAAQqC,QAAQtC,QAAS,GACpDA,OAAOO,SAAS8B,OAAOrC,OAAOO,SAAS+B,QAAQhC,OAAQ,OAGnDuC,KAAO7C,WACN,IAAIa,EAAI,EAAGA,EAAI+B,SAAW,IAAK/B,EAAG,KAClCf,KAAO,CACVG,QAAS,GACTM,SAAU,GACVkC,MAAOzC,OAAOyC,MAAQ5B,EAAI,EAC1BgB,MAAOP,UAAUT,EAAGb,OAAQM,QAG7BiB,MAAMO,IAAIhC,KAAK+B,MAAO/B,MACtBA,KAAKG,QAAQE,KAAK0C,MAClBA,KAAKtC,SAASJ,KAAKL,MAEnB+C,KAAO/C,KAGRQ,MAAML,QAAQE,KAAK0C,MACnBA,KAAKtC,SAASJ,KAAKG,SHhBtBwC,CAAUvB,MAAOD,WDHlB,SAAwBC,WACnBL,MAAQ6B,MAAMC,KAAKzB,MAAMY,UAGzBM,MAAQ,EACRQ,SAAW/B,MAAMgC,OAAOC,GAAiB,IAAZA,EAAEV,WAC9B,IAAKW,MAAOtD,QAASmD,SAASjB,UAClClC,KAAKuD,MAAQD,aAGD,CACZX,YACIa,MAAQpC,MAAMgC,OAAOC,GAAKA,EAAEV,QAAUA,UAErB,IAAjBa,MAAMxC,OAAc,SACH,IAAjBwC,MAAMxC,OAAc,CACvBwC,MAAM,GAAGD,MAAQ,eAKdA,MAAQ,IAAI1B,QACX,IAAI7B,QAAQwD,MAAO,KAEnBC,IADMzD,KAAKG,QAAQuD,OAAO,CAACC,EAAGC,IAAOD,GAAKC,EAAEL,MAAQ,GACxCvD,KAAKG,QAAQa,OAC7BuC,MAAMvB,IAAIhC,KAAMyD,SAIbI,MAAQ,IAAIhC,QACX,IAAI7B,QAAQwD,MAChBK,MAAM7B,IAAIhC,KAAMA,KAAKG,QAAQ2D,IAAIF,GAAKT,SAASX,QAAQoB,KAIxDJ,MAAQA,MAAMO,KAAK,CAACC,EAAGC,IAAMV,MAAMnB,IAAI4B,GAAKT,MAAMnB,IAAI6B,QAGlDC,UAAW,QACPA,UAAU,CACjBA,UAAW,MACN,IAAInD,EAAI,EAAGA,GAAKyC,MAAMxC,OAAS,IAAKD,EAG7BJ,WAFEkD,MAAMzB,IAAIoB,MAAMzC,IAChB8C,MAAMzB,IAAIoB,MAAMzC,EAAI,OAGhCmD,UAAW,GACVV,MAAMzC,GAAIyC,MAAMzC,EAAI,IAAM,CAACyC,MAAMzC,EAAI,GAAIyC,MAAMzC,SAK9C,IAAKuC,MAAOtD,QAASwD,MAAMtB,UAC/BlC,KAAKuD,MAAQD,MAGdH,SAAWK,OCpDZW,CAAe1C,OHPD,SAASA,MAAO2C,WAAa,SACvChD,MAAQ6B,MAAMC,KAAKzB,MAAMY,UACzBc,SAAW,IAAItB,QAEd,IAAI7B,QAAQoB,MAChBpB,KAAKqE,EAAIrE,KAAKuD,MACdvD,KAAKsE,EAAItE,KAAK2C,UAGV,IAAI5B,EAAI,EAAGA,EAAIqD,aAAcrD,EAAG,KAEhCwD,WAAa,IAAI1C,QAChB,IAAI7B,QAAQoB,MAAO,KACnBoD,KAAOrB,SAASf,IAAIpC,MACZC,MAARuE,KACHD,WAAWvC,IAAIhC,KAAM,GAErBuE,WAAWvC,IAAIhC,KAAMA,KAAKqE,EAAIG,UAK3B,IAAIxE,QAAQoB,MAChB+B,SAASnB,IAAIhC,KAAMA,KAAKqE,OAIrBC,EAAI,SACK,KAeRvD,EAdA0D,UAAY,IAAI5C,IAEhB2B,MAAQpC,MAAMgC,OAAOC,GAAKA,EAAEV,QAAU2B,GAAGP,KAAK,CAACC,EAAGC,IAAMD,EAAEK,EAAIJ,EAAEI,MAC/C,IAAjBb,MAAMxC,OAAc,UAEnB,IAAIhB,QAAQwD,MAAO,CAEvBiB,UAAUzC,IAAIhC,KAAM,OACf,IAAI0E,YAAa,IAAI1E,KAAKS,YAAaT,KAAKG,SAAU,KACtDwE,OAASxB,SAASf,IAAIsC,WAAavB,SAASf,IAAIpC,OAASH,MAC7D4E,UAAUzC,IAAIhC,KAAMyE,UAAUrC,IAAIpC,MAAQ2E,YAKxCC,WAAa,EACbC,YAAa,EAAA,MACZ9D,EAAI,EAAGA,EAAIyC,MAAMxC,SAAUD,EAAG,KAC9Bf,KAAOwD,MAAMzC,GACb+D,OAAS9E,KAAKqE,EAAII,UAAUrC,IAAIpC,SAE1B,IAANe,GAAW+D,OAASD,WAEvBA,WAAa3D,KAAK6D,IAAIF,WAAYA,WAAa/E,aAAcgF,OAAShF,kBAChE,KAEFkF,MAAQxB,MAAMyB,MAAML,WAAY7D,GAChCmE,QAAUF,MAAMtB,OAAO,CAACyB,EAAG9B,IAAM8B,EAAIV,UAAUrC,IAAIiB,GAAI,GAAK2B,MAAMhE,WACjE,IAAIhB,QAAQgF,MAAOP,UAAUzC,IAAIhC,KAAMkF,SAE5CN,WAAa7D,EACb8D,WAAaC,OAAShF,kBAKpBkF,MAAQxB,MAAMyB,MAAML,WAAY7D,GAChCmE,QAAUF,MAAMtB,OAAO,CAACyB,EAAG9B,IAAM8B,EAAIV,UAAUrC,IAAIiB,GAAI,GAAK2B,MAAMhE,WACjE,IAAIhB,QAAQgF,MAAOP,UAAUzC,IAAIhC,KAAMkF,aAGvC,IAAKlF,KAAMoF,YAAaX,UAAWzE,KAAKqE,GAAKe,SAElDd,MGhEFxD,CAAQW,OIdT,SAAwBA,WACnBL,MAAQ6B,MAAMC,KAAKzB,MAAMY,UACzBgD,SAAWjE,MAAMsC,OACpB,EAAE4B,IAAKP,KAAM/E,OACL,CAACkB,KAAKoE,IAAItF,KAAKqE,EAAGiB,KAAMpE,KAAK6D,IAAI/E,KAAKqE,EAAGU,MAEjD,CAAC3D,MAAM,GAAGiD,EAAGjD,MAAM,GAAGiD,KAGlBkB,KAAMC,MAAQH,SACfI,QAAUD,KAAOD,MAAQ,EAAIA,SAE5B,IAAIvF,QAAQoB,MAAOpB,KAAKqE,GAAKoB,OJGlCC,CAAMjE,OAECA"}