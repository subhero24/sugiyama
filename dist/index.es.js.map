{"version":3,"file":"index.es.js","sources":["../src/balance.js","../src/topology.js","../src/calculate-order.js","../src/index.js","../src/minimize.js","../src/calculate-level.js","../src/normalize.js","../src/shift.js"],"sourcesContent":["// Balance is an iterative method to adjust the position (but not order) to improve graph aesthetics\n\nconst FORCE = 0.1;\nconst MIN_DISTANCE = 1;\n\n// Limiting the max force is necessary because the constraint of the minimum distance\n// displaces siblings to account for this distance, which can increase spring lengths,\n// which can increase the force of the springs and make the solution unstable\n\nexport default function(graph, options = {}) {\n\tlet { width, height, margin, iterations } = options;\n\n\tif (width == undefined) width = 0;\n\tif (height == undefined) height = 0;\n\tif (margin == undefined) margin = 1;\n\tif (iterations == undefined) iterations = 100;\n\n\tlet dimensions = new Map();\n\tfor (let [key, value] of graph.entries()) {\n\t\tdimensions.set(value, {\n\t\t\twidth: typeof width === 'function' ? width(key) || 0 : width,\n\t\t\theight: typeof height === 'function' ? height(key) || 0 : height,\n\t\t});\n\t}\n\n\tlet nodes = Array.from(graph.values());\n\n\t// Loop over all nodes and group them by level\n\tlet layers = [];\n\tfor (let node of nodes) {\n\t\tif (layers[node.level] == undefined) {\n\t\t\tlayers[node.level] = [];\n\t\t}\n\n\t\tlayers[node.level].push(node);\n\t}\n\n\tlet x = margin;\n\tfor (let level = 0; level < layers.length; ++level) {\n\t\tlet y = 0;\n\t\tlet nodes = layers[level].sort((a, b) => a.order - b.order);\n\t\tlet levelwidth = Math.max(...nodes.map(n => dimensions.get(n).width));\n\t\tfor (let node of layers[level]) {\n\t\t\tlet nodeheight = dimensions.get(node).height;\n\t\t\tnode.x = x + levelwidth / 2;\n\t\t\tnode.y = y + nodeheight / 2;\n\n\t\t\ty = y + nodeheight + margin;\n\t\t}\n\n\t\tlayers[level] = nodes;\n\t\tx = x + levelwidth + margin;\n\t}\n\n\tlet previous = new Map();\n\tfor (let i = 0; i < iterations; ++i) {\n\t\t// Calculate properties dependent on old coordinates, ie velocity\n\t\tlet velocities = new Map();\n\t\tfor (let node of nodes) {\n\t\t\tlet oldY = previous.get(node);\n\t\t\tif (oldY == undefined) {\n\t\t\t\tvelocities.set(node, 0);\n\t\t\t} else {\n\t\t\t\tvelocities.set(node, node.y - oldY);\n\t\t\t}\n\t\t}\n\n\t\t// Update old coordinates\n\t\tfor (let node of nodes) {\n\t\t\tprevious.set(node, node.y);\n\t\t}\n\n\t\t// Calculate layer node gradients\n\t\tfor (let level = 0; level < layers.length; level++) {\n\t\t\tlet layer = layers[level];\n\n\t\t\t// Calculate gradients according to neighbouring node springs\n\t\t\tlet gradients = new Map();\n\t\t\tfor (let node of layer) {\n\t\t\t\tgradients.set(node, 0);\n\t\t\t\tfor (let neighbour of [...node.children, ...node.parents]) {\n\t\t\t\t\tlet force = (previous.get(neighbour) - previous.get(node)) * FORCE;\n\t\t\t\t\tgradients.set(node, gradients.get(node) + force);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet j;\n\t\t\tlet blockIndex = 0;\n\t\t\tlet blockBound = -Infinity;\n\t\t\tfor (j = 0; j < layer.length; ++j) {\n\t\t\t\t// debugger;\n\t\t\t\tlet node = layer[j];\n\t\t\t\tlet height = dimensions.get(node).height;\n\t\t\t\tlet target = node.y + gradients.get(node);\n\t\t\t\tlet lowerbound = target - height / 2;\n\t\t\t\tlet upperbound = target + height / 2;\n\n\t\t\t\tif (j === 0 || lowerbound < blockBound) {\n\t\t\t\t\t// If the node's target is too close to the previous node, just continue grouping nodes\n\t\t\t\t\tblockBound = Math.max(blockBound, blockBound + margin, upperbound + margin);\n\t\t\t\t} else {\n\t\t\t\t\t// If the node's target will be too far away to belongs to the group, group the previous nodes and start a new group\n\t\t\t\t\tlet block = layer.slice(blockIndex, j);\n\t\t\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t\t\tblockIndex = j;\n\t\t\t\t\tblockBound = upperbound + margin;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All the last nodes also form a group\n\t\t\tlet block = layer.slice(blockIndex, j);\n\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t// Translate all nodes with their calculated gradient\n\t\t\tfor (let [node, gradient] of gradients) node.y += gradient;\n\t\t}\n\t}\n\n\treturn nodes;\n}\n","// Returns a map from the given nodes to an object that contains all the graph info\n\n// Calculates all ancestors of a node\nlet ancestors = node => {\n\t// Ancestors are already calculated\n\tif (node.ancestors != undefined) return node.ancestors;\n\n\t// Loop through all parents to add them as ancestors, and recursively add their ancestors too\n\tnode.ancestors = [];\n\tfor (let parent of node.parents) {\n\t\t// Check if the parent of this node was already added.\n\t\t// This only happens if the original nodes specified the same parent twice\n\t\tif (!node.ancestors.includes(parent)) {\n\t\t\tnode.ancestors.push(parent);\n\t\t\t// Find all ancestors of the parent and add them if necessary\n\t\t\tfor (let ancestor of ancestors(parent)) {\n\t\t\t\t// An ancestor could already be part of the ancestors if there was\n\t\t\t\t// another path in the graph leading to this ancestor\n\t\t\t\tif (!node.ancestors.includes(ancestor)) {\n\t\t\t\t\tnode.ancestors.push(ancestor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.ancestors;\n};\n\n// Calculates all descendents of a node\nlet descendents = node => {\n\t// Descendents are already calculated\n\tif (node.descendents != undefined) return node.descendents;\n\n\t// Loop through all children to add them as descendents, and recursively add their descendents too\n\tnode.descendents = [];\n\tfor (let child of node.children) {\n\t\t// Check if the child of this node was already added.\n\t\t// This only happens if the original nodes specified the same child twice\n\t\tif (!node.descendents.includes(child)) {\n\t\t\tnode.descendents.push(child);\n\t\t\t// Find all descendents of the child and add them if necessary\n\t\t\tfor (let descendent of descendents(child)) {\n\t\t\t\t// An descendent could already be part of the descendents if there was\n\t\t\t\t// another path in the graph leading to this descendent\n\t\t\t\tif (!node.descendents.includes(descendent)) {\n\t\t\t\t\tnode.descendents.push(descendent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.descendents;\n};\n\nexport default function(nodes, fns) {\n\tlet { childFunc, parentFunc } = fns;\n\n\tif (childFunc == undefined && parentFunc == undefined) {\n\t\tthrow new Error('Could not create topology without childFunc or parentFunc');\n\t}\n\n\t// Topology is a map linking the originial node with its corresponding graph information object\n\t// specifying parents, children, ancestors, descendents, position, ...\n\tlet topology = new Map();\n\tfor (let key of nodes) {\n\t\tlet value = {\n\t\t\tvalue: key,\n\t\t\tparents: [],\n\t\t\tchildren: [],\n\t\t};\n\n\t\ttopology.set(key, value);\n\t}\n\n\tif (parentFunc && childFunc) {\n\t\t// TODO: could use both funcs to calculate all relations in 1 iteration\n\t} else if (parentFunc) {\n\t\t// First we have to loop through all nodes as we can only go \"up\" the graph\n\t\t// and can therefore not know all children of a node while traversing it for the first time\n\n\t\tfor (let [node, nodeT] of topology.entries()) {\n\t\t\tlet parents = parentFunc(node);\n\t\t\tif (parents != undefined && parents.length !== 0) {\n\t\t\t\tfor (let parent of parents) {\n\t\t\t\t\tlet parentT = topology.get(parent);\n\t\t\t\t\tif (!nodeT.parents.includes(parentT)) nodeT.parents.push(parentT);\n\t\t\t\t\tif (!parentT.children.includes(nodeT)) parentT.children.push(nodeT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let nodeT of topology.values()) {\n\t\t\tancestors(nodeT);\n\t\t\tdescendents(nodeT);\n\t\t}\n\n\t\treturn topology;\n\t} else if (childFunc) {\n\t\t// TODO\n\t\tthrow new Error('childFunc not implemented');\n\t}\n}\n","// Assigns a vertical order of the nodes to minimize link crossings\n\nfunction shouldSwap(edges1, edges2) {\n\tlet balance = 0;\n\tfor (let i = 0; i < edges1.length; ++i) {\n\t\tfor (let j = i; j < edges2.length; ++j) {\n\t\t\tbalance += Math.sign(edges1[i] - edges2[j]);\n\t\t}\n\t}\n\treturn balance > 0;\n}\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\n\t// Start with orphans, and position them in order they are defined\n\tlet level = 0;\n\tlet previous = nodes.filter(n => n.level === 0);\n\tfor (let [index, node] of previous.entries()) {\n\t\tnode.order = index;\n\t}\n\n\twhile (true) {\n\t\tlevel++;\n\t\tlet layer = nodes.filter(n => n.level === level);\n\n\t\tif (layer.length === 0) break;\n\t\tif (layer.length === 1) {\n\t\t\tlayer[0].order = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//  Calculate all preferred node positions as average of parent positions\n\t\tlet order = new Map();\n\t\tfor (let node of layer) {\n\t\t\tlet sum = node.parents.reduce((s, p) => (s += p.order), 0);\n\t\t\tlet avg = sum / node.parents.length;\n\t\t\torder.set(node, avg);\n\t\t}\n\n\t\t// Calculate all parent edge arrays\n\t\tlet edges = new Map();\n\t\tfor (let node of layer) {\n\t\t\tedges.set(node, node.parents.map(p => previous.indexOf(p)));\n\t\t}\n\n\t\t// Sort the layer according to the calculated positions\n\t\tlayer = layer.sort((a, b) => order.get(a) - order.get(b));\n\n\t\t// Bubble sort the layer to minimize edge crossings\n\t\tlet finished = false;\n\t\twhile (!finished) {\n\t\t\tfinished = true;\n\t\t\tfor (let i = 0; i <= layer.length - 2; ++i) {\n\t\t\t\tlet edgesA = edges.get(layer[i]);\n\t\t\t\tlet edgesB = edges.get(layer[i + 1]);\n\t\t\t\tlet swap = shouldSwap(edgesA, edgesB);\n\t\t\t\tif (swap) {\n\t\t\t\t\tfinished = false;\n\t\t\t\t\t[layer[i], layer[i + 1]] = [layer[i + 1], layer[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let [index, node] of layer.entries()) {\n\t\t\tnode.order = index;\n\t\t}\n\n\t\tprevious = layer;\n\t}\n}\n","import shift from './shift';\nimport balance from './balance';\nimport topology from './topology';\nimport minimize from './minimize';\nimport normalize from './normalize';\nimport calculateOrder from './calculate-order';\nimport calculateLevel from './calculate-level';\n\nexport default function(nodes, fns) {\n\tlet { childrenFunc, parentFunc, dummyFunc, width, height, margin, iterations } = fns;\n\n\tlet graph = topology(nodes, { childrenFunc, parentFunc });\n\n\tminimize(graph);\n\tcalculateLevel(graph);\n\tnormalize(graph, { dummyFunc });\n\tcalculateOrder(graph);\n\tbalance(graph, { width, height, margin, iterations });\n\tshift(graph);\n\n\treturn graph;\n}\n","// This cleans up unnecessary edges which connects two nodes\n// that are already connected through intermediate nodes\nexport default function(graph) {\n\tlet nodes = graph.values();\n\tfor (let node of nodes) {\n\t\tfor (let parent of node.parents) {\n\t\t\tfor (let parentsibling of node.parents) {\n\t\t\t\tif (parentsibling === parent) continue;\n\t\t\t\tif (parentsibling.ancestors.includes(parent)) {\n\t\t\t\t\tnode.parents.splice(node.parents.indexOf(parent), 1);\n\t\t\t\t\tparent.children.splice(parent.children.indexOf(node), 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","// Assigns a level to all nodes depending on the horizontal order in the graph\n// A node moves it child nodes to a level + 1, parent nodes can not receive a levelup based on the level of it's child node.\nexport default function(graph) {\n\tfor (let node of graph.values()) {\n\t\tif (node.parents.length === 0) {\n\t\t\tsetLevel(node, 0);\n\t\t}\n\t}\n\n\tfunction setLevel(node, level, skip = []) {\n\t\tnode.level = level;\n\t\tfor (let child of node.children) {\n\t\t\tif (skip.includes(child)) continue;\n\t\t\tif (child.level == undefined || child.level < level + 1) {\n\t\t\t\tsetLevel(child, level + 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let parent of node.parents) {\n\t\t\tif (skip.includes(parent)) continue;\n\t\t\tif (parent.level == undefined) {\n\t\t\t\tsetLevel(parent, level - 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\t}\n}\n","// Normalize adds dummy nodes in the graph to avoid links spanning multiple levels\nexport default function(graph, options = {}) {\n\tlet defaults = {\n\t\tdummyFunc: () => ({}),\n\t};\n\n\tlet { dummyFunc } = { ...defaults, ...options };\n\n\tlet nodes = graph.values();\n\tfor (let parent of nodes) {\n\t\tfor (let child of parent.children) {\n\t\t\tlet distance = child.level - parent.level;\n\t\t\tif (distance > 1) {\n\t\t\t\t// If node and child span multiple levels, remove the relation between the two\n\t\t\t\t// A new node will be inserted to represent the relation\n\t\t\t\tchild.parents.splice(child.parents.indexOf(parent), 1);\n\t\t\t\tparent.children.splice(parent.children.indexOf(child), 1);\n\n\t\t\t\t// Roll through all the levels and adding as many nodes as necessary to span the level difference\n\t\t\t\tlet prev = parent;\n\t\t\t\tfor (let i = 0; i < distance - 1; ++i) {\n\t\t\t\t\tlet node = {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tlevel: parent.level + i + 1,\n\t\t\t\t\t\tvalue: dummyFunc(i, parent, child),\n\t\t\t\t\t};\n\n\t\t\t\t\tgraph.set(node.value, node);\n\t\t\t\t\tnode.parents.push(prev);\n\t\t\t\t\tprev.children.push(node);\n\n\t\t\t\t\tprev = node;\n\t\t\t\t}\n\n\t\t\t\tchild.parents.push(prev);\n\t\t\t\tprev.children.push(child);\n\t\t\t}\n\t\t}\n\t}\n}\n","// Shifts all nodes to vertically center the graph around the node in the first layer (x = 0)\n// that is closest to the vertical center of the graph\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\tlet interval = nodes.reduce(\n\t\t([min, max], node) => {\n\t\t\treturn [Math.min(node.y, min), Math.max(node.y, max)];\n\t\t},\n\t\t[nodes[0].y, nodes[0].y],\n\t);\n\n\tlet [minY, maxY] = interval;\n\tlet center = (maxY - minY) / 2 + minY;\n\n\tfor (let node of nodes) node.y -= center;\n}\n"],"names":["FORCE","ancestors","node","undefined","parent","parents","includes","push","ancestor","descendents","child","children","descendent","shouldSwap","edges1","edges2","balance","i","length","j","Math","sign","nodes","fns","childrenFunc","parentFunc","dummyFunc","width","height","margin","iterations","graph","childFunc","Error","topology","Map","key","value","set","nodeT","entries","parentT","get","values","parentsibling","splice","indexOf","minimize","setLevel","level","skip","calculateLevel","options","distance","prev","normalize","Array","from","previous","filter","n","index","order","layer","avg","reduce","s","p","edges","map","sort","a","b","finished","calculateOrder","dimensions","layers","x","y","levelwidth","max","nodeheight","velocities","oldY","gradients","neighbour","force","blockIndex","blockBound","target","lowerbound","upperbound","block","slice","average","g","gradient","interval","min","minY","maxY","center","shift"],"mappings":"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"}