"use strict";function shift(graph){let nodes=Array.from(graph.values()),interval=nodes.reduce(([min,max],node)=>[Math.min(node.y,min),Math.max(node.y,max)],[nodes[0].y,nodes[0].y]),[minY,maxY]=interval,center=(maxY-minY)/2+minY;for(let node of nodes)node.y-=center;return nodes}const FORCE=.1,MIN_DISTANCE=1;function balance(graph,iterations=100){let nodes=Array.from(graph.values()),previous=new Map;for(let node of nodes)node.y=node.order,node.x=node.level;for(let i=0;i<iterations;++i){let velocities=new Map;for(let node of nodes){let oldY=previous.get(node);null==oldY?velocities.set(node,0):velocities.set(node,node.y-oldY)}for(let node of nodes)previous.set(node,node.y);let x=0;for(;;){let i,gradients=new Map,layer=nodes.filter(n=>n.level===x).sort((a,b)=>a.y-b.y);if(0===layer.length)break;for(let node of layer){gradients.set(node,0);for(let neighbour of[...node.children,...node.parents]){let force=(previous.get(neighbour)-previous.get(node))*FORCE;gradients.set(node,gradients.get(node)+force)}}let blockIndex=0,blockBound=-1/0;for(i=0;i<layer.length;++i){let node=layer[i],target=node.y+gradients.get(node);if(0===i||target<blockBound)blockBound=Math.max(blockBound,blockBound+MIN_DISTANCE,target+MIN_DISTANCE);else{let block=layer.slice(blockIndex,i),average=block.reduce((g,n)=>g+gradients.get(n),0)/block.length;for(let node of block)gradients.set(node,average);blockIndex=i,blockBound=target+MIN_DISTANCE}}let block=layer.slice(blockIndex,i),average=block.reduce((g,n)=>g+gradients.get(n),0)/block.length;for(let node of block)gradients.set(node,average);for(let[node,gradient]of gradients)node.y+=gradient;x++}}return nodes}let ancestors=node=>{if(null!=node.ancestors)return node.ancestors;node.ancestors=[];for(let parent of node.parents)if(!node.ancestors.includes(parent)){node.ancestors.push(parent);for(let ancestor of ancestors(parent))node.ancestors.includes(ancestor)||node.ancestors.push(ancestor)}return node.ancestors},descendents=node=>{if(null!=node.descendents)return node.descendents;node.descendents=[];for(let child of node.children)if(!node.descendents.includes(child)){node.descendents.push(child);for(let descendent of descendents(child))node.descendents.includes(descendent)||node.descendents.push(descendent)}return node.descendents};function topology(nodes,fns){let{childFunc:childFunc,parentFunc:parentFunc}=fns;if(null==childFunc&&null==parentFunc)throw new Error("Could not create topology without childFunc or parentFunc");let topology=new Map;for(let key of nodes){let value={value:key,parents:[],children:[]};topology.set(key,value)}if(parentFunc&&childFunc);else{if(parentFunc){for(let[node,nodeT]of topology.entries()){let parents=parentFunc(node);if(null!=parents&&0!==parents.length)for(let parent of parents){let parentT=topology.get(parent);nodeT.parents.includes(parentT)||nodeT.parents.push(parentT),parentT.children.includes(nodeT)||parentT.children.push(nodeT)}}for(let nodeT of topology.values())ancestors(nodeT),descendents(nodeT);return topology}if(childFunc)throw new Error("childFunc not implemented")}}function minimize(graph){let nodes=graph.values();for(let node of nodes)for(let parent of node.parents)for(let parentsibling of node.parents)parentsibling!==parent&&parentsibling.ancestors.includes(parent)&&(node.parents.splice(node.parents.indexOf(parent),1),parent.children.splice(parent.children.indexOf(node),1))}function normalize(graph,dummyFunc=(()=>({}))){let nodes=graph.values();for(let parent of nodes)for(let child of parent.children){let distance=child.level-parent.level;if(distance>1){child.parents.splice(child.parents.indexOf(parent),1),parent.children.splice(parent.children.indexOf(child),1);let prev=parent;for(let i=0;i<distance-1;++i){let node={parents:[],children:[],level:parent.level+i+1,value:dummyFunc(i,parent,child)};graph.set(node.value,node),node.parents.push(prev),prev.children.push(node),prev=node}child.parents.push(prev),prev.children.push(child)}}}function shouldSwap(edges1,edges2){let balance=0;for(let i=0;i<edges1.length;++i)for(let j=i;j<edges2.length;++j)balance+=Math.sign(edges1[i]-edges2[j]);return balance>0}function calculateOrder(graph){let nodes=Array.from(graph.values()),level=0,previous=nodes.filter(n=>0===n.level);for(let[index,node]of previous.entries())node.order=index;for(;;){level++;let layer=nodes.filter(n=>n.level===level);if(0===layer.length)break;if(1===layer.length){layer[0].order=0;continue}let order=new Map;for(let node of layer){let avg=node.parents.reduce((s,p)=>s+=p.order,0)/node.parents.length;order.set(node,avg)}let edges=new Map;for(let node of layer)edges.set(node,node.parents.map(p=>previous.indexOf(p)));layer=layer.sort((a,b)=>order.get(a)-order.get(b));let finished=!1;for(;!finished;){finished=!0;for(let i=0;i<=layer.length-2;++i){shouldSwap(edges.get(layer[i]),edges.get(layer[i+1]))&&(finished=!1,[layer[i],layer[i+1]]=[layer[i+1],layer[i]])}}for(let[index,node]of layer.entries())node.order=index;previous=layer}}function calculateLevel(graph){for(let node of graph.values())0===node.parents.length&&setLevel(node,0);function setLevel(node,level,skip=[]){node.level=level;for(let child of node.children)skip.includes(child)||(null==child.level||child.level<level+1)&&setLevel(child,level+1,[...skip,node]);for(let parent of node.parents)skip.includes(parent)||null==parent.level&&setLevel(parent,level-1,[...skip,node])}}function layout(nodes,fns){let{childrenFunc:childrenFunc,parentFunc:parentFunc,dummyFunc:dummyFunc}=fns,graph=topology(nodes,{childrenFunc:childrenFunc,parentFunc:parentFunc});return minimize(graph),calculateLevel(graph),normalize(graph,dummyFunc),calculateOrder(graph),balance(graph),shift(graph),graph}module.exports=layout;
//# sourceMappingURL=index.js.map
