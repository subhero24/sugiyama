{"version":3,"file":"index.js","sources":["../src/shift.js","../src/balance.js","../src/topology.js","../src/minimize.js","../src/normalize.js","../src/calculate-order.js","../src/calculate-level.js","../src/index.js"],"sourcesContent":["// Shifts all nodes to vertically center the graph around the node in the first layer (x = 0)\n// that is closest to the vertical center of the graph\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\tlet interval = nodes.reduce(\n\t\t([min, max], node) => {\n\t\t\treturn [Math.min(node.y, min), Math.max(node.y, max)];\n\t\t},\n\t\t[nodes[0].y, nodes[0].y],\n\t);\n\n\tlet [minY, maxY] = interval;\n\tlet center = (maxY - minY) / 2 + minY;\n\n\tfor (let node of nodes) node.y -= center;\n}\n","// Balance is an iterative method to adjust the position (but not order) to improve graph aesthetics\n\nconst FORCE = 0.1;\nconst MIN_DISTANCE = 1;\n\n// Limiting the max force is necessary because the constraint of the minimum distance\n// displaces siblings to account for this distance, which can increase spring lengths,\n// which can increase the force of the springs and make the solution unstable\n\nexport default function(graph, options = {}) {\n\tlet { width, height, margin, iterations } = options;\n\n\tif (width == undefined) width = 0;\n\tif (height == undefined) height = 0;\n\tif (margin == undefined) margin = 1;\n\tif (iterations == undefined) iterations = 100;\n\n\tlet dimensions = new Map();\n\tfor (let [key, value] of graph.entries()) {\n\t\tdimensions.set(value, {\n\t\t\twidth: typeof width === 'function' ? width(key) || 0 : width,\n\t\t\theight: typeof height === 'function' ? height(key) || 0 : height,\n\t\t});\n\t}\n\n\tlet nodes = Array.from(graph.values());\n\n\t// Loop over all nodes and group them by level\n\tlet layers = [];\n\tfor (let node of nodes) {\n\t\tif (layers[node.level] == undefined) {\n\t\t\tlayers[node.level] = [];\n\t\t}\n\n\t\tlayers[node.level].push(node);\n\t}\n\n\tlet x = margin;\n\tfor (let level = 0; level < layers.length; ++level) {\n\t\tlet y = 0;\n\t\tlet nodes = layers[level].sort((a, b) => a.order - b.order);\n\t\tlet levelwidth = Math.max(...nodes.map(n => dimensions.get(n).width));\n\t\tfor (let node of layers[level]) {\n\t\t\tlet nodeheight = dimensions.get(node).height;\n\t\t\tnode.x = x + levelwidth / 2;\n\t\t\tnode.y = y + nodeheight / 2;\n\n\t\t\ty = y + nodeheight + margin;\n\t\t}\n\n\t\tlayers[level] = nodes;\n\t\tx = x + levelwidth + margin;\n\t}\n\n\tlet previous = new Map();\n\tfor (let i = 0; i < iterations; ++i) {\n\t\t// Calculate properties dependent on old coordinates, ie velocity\n\t\tlet velocities = new Map();\n\t\tfor (let node of nodes) {\n\t\t\tlet oldY = previous.get(node);\n\t\t\tif (oldY == undefined) {\n\t\t\t\tvelocities.set(node, 0);\n\t\t\t} else {\n\t\t\t\tvelocities.set(node, node.y - oldY);\n\t\t\t}\n\t\t}\n\n\t\t// Update old coordinates\n\t\tfor (let node of nodes) {\n\t\t\tprevious.set(node, node.y);\n\t\t}\n\n\t\t// Calculate layer node gradients\n\t\tfor (let level = 0; level < layers.length; level++) {\n\t\t\tlet layer = layers[level];\n\n\t\t\t// Calculate gradients according to neighbouring node springs\n\t\t\tlet gradients = new Map();\n\t\t\tfor (let node of layer) {\n\t\t\t\tgradients.set(node, 0);\n\t\t\t\tfor (let neighbour of [...node.children, ...node.parents]) {\n\t\t\t\t\tlet force = (previous.get(neighbour) - previous.get(node)) * FORCE;\n\t\t\t\t\tgradients.set(node, gradients.get(node) + force);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet j;\n\t\t\tlet blockIndex = 0;\n\t\t\tlet blockBound = -Infinity;\n\t\t\tfor (j = 0; j < layer.length; ++j) {\n\t\t\t\t// debugger;\n\t\t\t\tlet node = layer[j];\n\t\t\t\tlet height = dimensions.get(node).height;\n\t\t\t\tlet target = node.y + gradients.get(node);\n\t\t\t\tlet lowerbound = target - height / 2;\n\t\t\t\tlet upperbound = target + height / 2;\n\n\t\t\t\tif (j === 0 || lowerbound < blockBound) {\n\t\t\t\t\t// If the node's target is too close to the previous node, just continue grouping nodes\n\t\t\t\t\tblockBound = Math.max(blockBound, blockBound + margin, upperbound + margin);\n\t\t\t\t} else {\n\t\t\t\t\t// If the node's target will be too far away to belongs to the group, group the previous nodes and start a new group\n\t\t\t\t\tlet block = layer.slice(blockIndex, j);\n\t\t\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t\t\tblockIndex = j;\n\t\t\t\t\tblockBound = upperbound + margin;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All the last nodes also form a group\n\t\t\tlet block = layer.slice(blockIndex, j);\n\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t// Translate all nodes with their calculated gradient\n\t\t\tfor (let [node, gradient] of gradients) node.y += gradient;\n\t\t}\n\t}\n\n\treturn nodes;\n}\n","// Returns a map from the given nodes to an object that contains all the graph info\n\n// Calculates all ancestors of a node\nlet ancestors = node => {\n\t// Ancestors are already calculated\n\tif (node.ancestors != undefined) return node.ancestors;\n\n\t// Loop through all parents to add them as ancestors, and recursively add their ancestors too\n\tnode.ancestors = [];\n\tfor (let parent of node.parents) {\n\t\t// Check if the parent of this node was already added.\n\t\t// This only happens if the original nodes specified the same parent twice\n\t\tif (!node.ancestors.includes(parent)) {\n\t\t\tnode.ancestors.push(parent);\n\t\t\t// Find all ancestors of the parent and add them if necessary\n\t\t\tfor (let ancestor of ancestors(parent)) {\n\t\t\t\t// An ancestor could already be part of the ancestors if there was\n\t\t\t\t// another path in the graph leading to this ancestor\n\t\t\t\tif (!node.ancestors.includes(ancestor)) {\n\t\t\t\t\tnode.ancestors.push(ancestor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.ancestors;\n};\n\n// Calculates all descendents of a node\nlet descendents = node => {\n\t// Descendents are already calculated\n\tif (node.descendents != undefined) return node.descendents;\n\n\t// Loop through all children to add them as descendents, and recursively add their descendents too\n\tnode.descendents = [];\n\tfor (let child of node.children) {\n\t\t// Check if the child of this node was already added.\n\t\t// This only happens if the original nodes specified the same child twice\n\t\tif (!node.descendents.includes(child)) {\n\t\t\tnode.descendents.push(child);\n\t\t\t// Find all descendents of the child and add them if necessary\n\t\t\tfor (let descendent of descendents(child)) {\n\t\t\t\t// An descendent could already be part of the descendents if there was\n\t\t\t\t// another path in the graph leading to this descendent\n\t\t\t\tif (!node.descendents.includes(descendent)) {\n\t\t\t\t\tnode.descendents.push(descendent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.descendents;\n};\n\nexport default function(nodes, fns) {\n\tlet { childFunc, parentFunc } = fns;\n\n\tif (childFunc == undefined && parentFunc == undefined) {\n\t\tthrow new Error('Could not create topology without childFunc or parentFunc');\n\t}\n\n\t// Topology is a map linking the originial node with its corresponding graph information object\n\t// specifying parents, children, ancestors, descendents, position, ...\n\tlet topology = new Map();\n\tfor (let key of nodes) {\n\t\tlet value = {\n\t\t\tvalue: key,\n\t\t\tparents: [],\n\t\t\tchildren: [],\n\t\t};\n\n\t\ttopology.set(key, value);\n\t}\n\n\tif (parentFunc && childFunc) {\n\t\t// TODO: could use both funcs to calculate all relations in 1 iteration\n\t} else if (parentFunc) {\n\t\t// First we have to loop through all nodes as we can only go \"up\" the graph\n\t\t// and can therefore not know all children of a node while traversing it for the first time\n\n\t\tfor (let [node, nodeT] of topology.entries()) {\n\t\t\tlet parents = parentFunc(node);\n\t\t\tif (parents != undefined && parents.length !== 0) {\n\t\t\t\tfor (let parent of parents) {\n\t\t\t\t\tlet parentT = topology.get(parent);\n\t\t\t\t\tif (!nodeT.parents.includes(parentT)) nodeT.parents.push(parentT);\n\t\t\t\t\tif (!parentT.children.includes(nodeT)) parentT.children.push(nodeT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let nodeT of topology.values()) {\n\t\t\tancestors(nodeT);\n\t\t\tdescendents(nodeT);\n\t\t}\n\n\t\treturn topology;\n\t} else if (childFunc) {\n\t\t// TODO\n\t\tthrow new Error('childFunc not implemented');\n\t}\n}\n","// This cleans up unnecessary edges which connects two nodes\n// that are already connected through intermediate nodes\nexport default function(graph) {\n\tlet nodes = graph.values();\n\tfor (let node of nodes) {\n\t\tfor (let parent of node.parents) {\n\t\t\tfor (let parentsibling of node.parents) {\n\t\t\t\tif (parentsibling === parent) continue;\n\t\t\t\tif (parentsibling.ancestors.includes(parent)) {\n\t\t\t\t\tnode.parents.splice(node.parents.indexOf(parent), 1);\n\t\t\t\t\tparent.children.splice(parent.children.indexOf(node), 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","// Normalize adds dummy nodes in the graph to avoid links spanning multiple levels\nexport default function(graph, options = {}) {\n\tlet defaults = {\n\t\tdummyFunc: () => ({}),\n\t};\n\n\tlet { dummyFunc } = { ...defaults, ...options };\n\n\tlet nodes = graph.values();\n\tfor (let parent of nodes) {\n\t\tfor (let child of parent.children) {\n\t\t\tlet distance = child.level - parent.level;\n\t\t\tif (distance > 1) {\n\t\t\t\t// If node and child span multiple levels, remove the relation between the two\n\t\t\t\t// A new node will be inserted to represent the relation\n\t\t\t\tchild.parents.splice(child.parents.indexOf(parent), 1);\n\t\t\t\tparent.children.splice(parent.children.indexOf(child), 1);\n\n\t\t\t\t// Roll through all the levels and adding as many nodes as necessary to span the level difference\n\t\t\t\tlet prev = parent;\n\t\t\t\tfor (let i = 0; i < distance - 1; ++i) {\n\t\t\t\t\tlet node = {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tlevel: parent.level + i + 1,\n\t\t\t\t\t\tvalue: dummyFunc(i, parent, child),\n\t\t\t\t\t};\n\n\t\t\t\t\tgraph.set(node.value, node);\n\t\t\t\t\tnode.parents.push(prev);\n\t\t\t\t\tprev.children.push(node);\n\n\t\t\t\t\tprev = node;\n\t\t\t\t}\n\n\t\t\t\tchild.parents.push(prev);\n\t\t\t\tprev.children.push(child);\n\t\t\t}\n\t\t}\n\t}\n}\n","// Assigns a vertical order of the nodes to minimize link crossings\n\nfunction shouldSwap(edges1, edges2) {\n\tlet balance = 0;\n\tfor (let i = 0; i < edges1.length; ++i) {\n\t\tfor (let j = i; j < edges2.length; ++j) {\n\t\t\tbalance += Math.sign(edges1[i] - edges2[j]);\n\t\t}\n\t}\n\treturn balance > 0;\n}\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\n\t// Start with orphans, and position them in order they are defined\n\tlet level = 0;\n\tlet previous = nodes.filter(n => n.level === 0);\n\tfor (let [index, node] of previous.entries()) {\n\t\tnode.order = index;\n\t}\n\n\twhile (true) {\n\t\tlevel++;\n\t\tlet layer = nodes.filter(n => n.level === level);\n\n\t\tif (layer.length === 0) break;\n\t\tif (layer.length === 1) {\n\t\t\tlayer[0].order = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//  Calculate all preferred node positions as average of parent positions\n\t\tlet order = new Map();\n\t\tfor (let node of layer) {\n\t\t\tlet sum = node.parents.reduce((s, p) => (s += p.order), 0);\n\t\t\tlet avg = sum / node.parents.length;\n\t\t\torder.set(node, avg);\n\t\t}\n\n\t\t// Calculate all parent edge arrays\n\t\tlet edges = new Map();\n\t\tfor (let node of layer) {\n\t\t\tedges.set(node, node.parents.map(p => previous.indexOf(p)));\n\t\t}\n\n\t\t// Sort the layer according to the calculated positions\n\t\tlayer = layer.sort((a, b) => order.get(a) - order.get(b));\n\n\t\t// Bubble sort the layer to minimize edge crossings\n\t\tlet finished = false;\n\t\twhile (!finished) {\n\t\t\tfinished = true;\n\t\t\tfor (let i = 0; i <= layer.length - 2; ++i) {\n\t\t\t\tlet edgesA = edges.get(layer[i]);\n\t\t\t\tlet edgesB = edges.get(layer[i + 1]);\n\t\t\t\tlet swap = shouldSwap(edgesA, edgesB);\n\t\t\t\tif (swap) {\n\t\t\t\t\tfinished = false;\n\t\t\t\t\t[layer[i], layer[i + 1]] = [layer[i + 1], layer[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let [index, node] of layer.entries()) {\n\t\t\tnode.order = index;\n\t\t}\n\n\t\tprevious = layer;\n\t}\n}\n","// Assigns a level to all nodes depending on the horizontal order in the graph\n// A node moves it child nodes to a level + 1, parent nodes can not receive a levelup based on the level of it's child node.\nexport default function(graph) {\n\tfor (let node of graph.values()) {\n\t\tif (node.parents.length === 0) {\n\t\t\tsetLevel(node, 0);\n\t\t}\n\t}\n\n\tfunction setLevel(node, level, skip = []) {\n\t\tnode.level = level;\n\t\tfor (let child of node.children) {\n\t\t\tif (skip.includes(child)) continue;\n\t\t\tif (child.level == undefined || child.level < level + 1) {\n\t\t\t\tsetLevel(child, level + 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let parent of node.parents) {\n\t\t\tif (skip.includes(parent)) continue;\n\t\t\tif (parent.level == undefined) {\n\t\t\t\tsetLevel(parent, level - 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\t}\n}\n","import shift from './shift';\nimport balance from './balance';\nimport topology from './topology';\nimport minimize from './minimize';\nimport normalize from './normalize';\nimport calculateOrder from './calculate-order';\nimport calculateLevel from './calculate-level';\n\nexport default function(nodes, fns) {\n\tlet { childrenFunc, parentFunc, dummyFunc, width, height, margin, iterations } = fns;\n\n\tlet graph = topology(nodes, { childrenFunc, parentFunc });\n\n\tminimize(graph);\n\tcalculateLevel(graph);\n\tnormalize(graph, { dummyFunc });\n\tcalculateOrder(graph);\n\tbalance(graph, { width, height, margin, iterations });\n\tshift(graph);\n\n\treturn graph;\n}\n"],"names":["graph","nodes","Array","from","values","interval","reduce","min","max","node","Math","y","minY","maxY","center","FORCE","options","width","height","margin","iterations","undefined","dimensions","Map","key","value","entries","set","layers","level","push","x","length","sort","a","b","order","levelwidth","map","n","get","nodeheight","previous","i","velocities","oldY","j","layer","gradients","neighbour","children","parents","force","blockIndex","blockBound","Infinity","target","lowerbound","upperbound","block","slice","average","g","gradient","ancestors","parent","includes","ancestor","descendents","child","descendent","fns","childFunc","parentFunc","Error","topology","nodeT","parentT","parentsibling","splice","indexOf","dummyFunc","distance","prev","shouldSwap","edges1","edges2","balance","sign","filter","index","avg","s","p","edges","finished","setLevel","skip","childrenFunc","minimize","calculateLevel","normalize","calculateOrder","shift"],"mappings":"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"}