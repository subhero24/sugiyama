{"version":3,"file":"index.js","sources":["../src/shift.js","../src/balance.js","../src/topology.js","../src/minimize.js","../src/normalize.js","../src/calculate-order.js","../src/calculate-level.js","../src/layout.js"],"sourcesContent":["// Shifts all nodes to vertically center the graph around the node in the first layer (x = 0)\n// that is closest to the vertical center of the graph\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\tlet interval = nodes.reduce(\n\t\t([min, max], node) => {\n\t\t\treturn [Math.min(node.y, min), Math.max(node.y, max)];\n\t\t},\n\t\t[nodes[0].y, nodes[0].y],\n\t);\n\n\tlet [minY, maxY] = interval;\n\tlet center = (maxY - minY) / 2 + minY;\n\n\tfor (let node of nodes) node.y -= center;\n\n\treturn nodes;\n}\n","// Balance is an iterative method to adjust the position (but not order) to improve graph aesthetics\n\nconst FORCE = 0.1;\nconst MIN_DISTANCE = 1;\n\n// Limiting the max force is necessary because the constraint of the minimum distance\n// displaces siblings to account for this distance, which can increase spring lengths,\n// which can increase the force of the springs and make the solution unstable\n\nexport default function(graph, iterations = 100) {\n\tlet nodes = Array.from(graph.values());\n\tlet previous = new Map();\n\n\tfor (let node of nodes) {\n\t\tnode.y = node.order;\n\t\tnode.x = node.level;\n\t}\n\n\tfor (let i = 0; i < iterations; ++i) {\n\t\t// Calculate properties dependent on old coordinates, ie velocity\n\t\tlet velocities = new Map();\n\t\tfor (let node of nodes) {\n\t\t\tlet oldY = previous.get(node);\n\t\t\tif (oldY == undefined) {\n\t\t\t\tvelocities.set(node, 0);\n\t\t\t} else {\n\t\t\t\tvelocities.set(node, node.y - oldY);\n\t\t\t}\n\t\t}\n\n\t\t// Update old coordinates\n\t\tfor (let node of nodes) {\n\t\t\tprevious.set(node, node.y);\n\t\t}\n\n\t\t// Calculate layer node gradients\n\t\tlet x = 0;\n\t\twhile (true) {\n\t\t\tlet gradients = new Map();\n\n\t\t\tlet layer = nodes.filter(n => n.level === x).sort((a, b) => a.y - b.y);\n\t\t\tif (layer.length === 0) break;\n\n\t\t\tfor (let node of layer) {\n\t\t\t\t// Neighbouring child springs\n\t\t\t\tgradients.set(node, 0);\n\t\t\t\tfor (let neighbour of [...node.children, ...node.parents]) {\n\t\t\t\t\tlet force = (previous.get(neighbour) - previous.get(node)) * FORCE;\n\t\t\t\t\tgradients.set(node, gradients.get(node) + force);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet i;\n\t\t\tlet blockIndex = 0;\n\t\t\tlet blockBound = -Infinity;\n\t\t\tfor (i = 0; i < layer.length; ++i) {\n\t\t\t\tlet node = layer[i];\n\t\t\t\tlet target = node.y + gradients.get(node);\n\n\t\t\t\tif (i === 0 || target < blockBound) {\n\t\t\t\t\t// If the node's target is too close to the previous node, just continue grouping nodes\n\t\t\t\t\tblockBound = Math.max(blockBound, blockBound + MIN_DISTANCE, target + MIN_DISTANCE);\n\t\t\t\t} else {\n\t\t\t\t\t// If the node's target will be too far away to belongs to the group, group the previous nodes and start a new group\n\t\t\t\t\tlet block = layer.slice(blockIndex, i);\n\t\t\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t\t\tblockIndex = i;\n\t\t\t\t\tblockBound = target + MIN_DISTANCE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// All the last nodes also form a group\n\t\t\tlet block = layer.slice(blockIndex, i);\n\t\t\tlet average = block.reduce((g, n) => g + gradients.get(n), 0) / block.length;\n\t\t\tfor (let node of block) gradients.set(node, average);\n\n\t\t\t// Translate all nodes with their calculated gradient\n\t\t\tfor (let [node, gradient] of gradients) node.y += gradient;\n\n\t\t\tx++;\n\t\t}\n\t}\n\n\treturn nodes;\n}\n","// Returns a map from the given nodes to an object that contains all the graph info\n\n// Calculates all ancestors of a node\nlet ancestors = node => {\n\t// Ancestors are already calculated\n\tif (node.ancestors != undefined) return node.ancestors;\n\n\t// Loop through all parents to add them as ancestors, and recursively add their ancestors too\n\tnode.ancestors = [];\n\tfor (let parent of node.parents) {\n\t\t// Check if the parent of this node was already added.\n\t\t// This only happens if the original nodes specified the same parent twice\n\t\tif (!node.ancestors.includes(parent)) {\n\t\t\tnode.ancestors.push(parent);\n\t\t\t// Find all ancestors of the parent and add them if necessary\n\t\t\tfor (let ancestor of ancestors(parent)) {\n\t\t\t\t// An ancestor could already be part of the ancestors if there was\n\t\t\t\t// another path in the graph leading to this ancestor\n\t\t\t\tif (!node.ancestors.includes(ancestor)) {\n\t\t\t\t\tnode.ancestors.push(ancestor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.ancestors;\n};\n\n// Calculates all descendents of a node\nlet descendents = node => {\n\t// Descendents are already calculated\n\tif (node.descendents != undefined) return node.descendents;\n\n\t// Loop through all children to add them as descendents, and recursively add their descendents too\n\tnode.descendents = [];\n\tfor (let child of node.children) {\n\t\t// Check if the child of this node was already added.\n\t\t// This only happens if the original nodes specified the same child twice\n\t\tif (!node.descendents.includes(child)) {\n\t\t\tnode.descendents.push(child);\n\t\t\t// Find all descendents of the child and add them if necessary\n\t\t\tfor (let descendent of descendents(child)) {\n\t\t\t\t// An descendent could already be part of the descendents if there was\n\t\t\t\t// another path in the graph leading to this descendent\n\t\t\t\tif (!node.descendents.includes(descendent)) {\n\t\t\t\t\tnode.descendents.push(descendent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn node.descendents;\n};\n\nexport default function(nodes, fns) {\n\tlet { childFunc, parentFunc } = fns;\n\n\tif (childFunc == undefined && parentFunc == undefined) {\n\t\tthrow new Error('Could not create topology without childFunc or parentFunc');\n\t}\n\n\t// Topology is a map linking the originial node with its corresponding graph information object\n\t// specifying parents, children, ancestors, descendents, position, ...\n\tlet topology = new Map();\n\tfor (let key of nodes) {\n\t\tlet value = {\n\t\t\tvalue: key,\n\t\t\tparents: [],\n\t\t\tchildren: [],\n\t\t};\n\n\t\ttopology.set(key, value);\n\t}\n\n\tif (parentFunc && childFunc) {\n\t\t// TODO: could use both funcs to calculate all relations in 1 iteration\n\t} else if (parentFunc) {\n\t\t// First we have to loop through all nodes as we can only go \"up\" the graph\n\t\t// and can therefore not know all children of a node while traversing it for the first time\n\n\t\tfor (let [node, nodeT] of topology.entries()) {\n\t\t\tlet parents = parentFunc(node);\n\t\t\tif (parents != undefined && parents.length !== 0) {\n\t\t\t\tfor (let parent of parents) {\n\t\t\t\t\tlet parentT = topology.get(parent);\n\t\t\t\t\tif (!nodeT.parents.includes(parentT)) nodeT.parents.push(parentT);\n\t\t\t\t\tif (!parentT.children.includes(nodeT)) parentT.children.push(nodeT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let nodeT of topology.values()) {\n\t\t\tancestors(nodeT);\n\t\t\tdescendents(nodeT);\n\t\t}\n\n\t\treturn topology;\n\t} else if (childFunc) {\n\t\t// TODO\n\t\tthrow new Error('childFunc not implemented');\n\t}\n}\n","// This cleans up unnecessary edges which connects two nodes\n// that are already connected through intermediate nodes\nexport default function(graph) {\n\tlet nodes = graph.values();\n\tfor (let node of nodes) {\n\t\tfor (let parent of node.parents) {\n\t\t\tfor (let parentsibling of node.parents) {\n\t\t\t\tif (parentsibling === parent) continue;\n\t\t\t\tif (parentsibling.ancestors.includes(parent)) {\n\t\t\t\t\tnode.parents.splice(node.parents.indexOf(parent), 1);\n\t\t\t\t\tparent.children.splice(parent.children.indexOf(node), 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","// Normalize adds dummy nodes in the graph to avoid links spanning multiple levels\nexport default function(graph, dummyFunc = () => ({})) {\n\tlet nodes = graph.values();\n\n\tfor (let parent of nodes) {\n\t\tfor (let child of parent.children) {\n\t\t\tlet distance = child.level - parent.level;\n\t\t\tif (distance > 1) {\n\t\t\t\t// If node and child span multiple levels, remove the relation between the two\n\t\t\t\t// A new node will be inserted to represent the relation\n\t\t\t\tchild.parents.splice(child.parents.indexOf(parent), 1);\n\t\t\t\tparent.children.splice(parent.children.indexOf(child), 1);\n\n\t\t\t\t// Roll through all the levels and adding as many nodes as necessary to span the level difference\n\t\t\t\tlet prev = parent;\n\t\t\t\tfor (let i = 0; i < distance - 1; ++i) {\n\t\t\t\t\tlet node = {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: [],\n\t\t\t\t\t\tlevel: parent.level + i + 1,\n\t\t\t\t\t\tvalue: dummyFunc(i, parent, child),\n\t\t\t\t\t};\n\n\t\t\t\t\tgraph.set(node.value, node);\n\t\t\t\t\tnode.parents.push(prev);\n\t\t\t\t\tprev.children.push(node);\n\n\t\t\t\t\tprev = node;\n\t\t\t\t}\n\n\t\t\t\tchild.parents.push(prev);\n\t\t\t\tprev.children.push(child);\n\t\t\t}\n\t\t}\n\t}\n}\n","// Assigns a vertical order of the nodes to minimize link crossings\n\nfunction shouldSwap(edges1, edges2) {\n\tlet balance = 0;\n\tfor (let i = 0; i < edges1.length; ++i) {\n\t\tfor (let j = i; j < edges2.length; ++j) {\n\t\t\tbalance += Math.sign(edges1[i] - edges2[j]);\n\t\t}\n\t}\n\treturn balance > 0;\n}\n\nexport default function(graph) {\n\tlet nodes = Array.from(graph.values());\n\n\t// Start with orphans, and position them in order they are defined\n\tlet level = 0;\n\tlet previous = nodes.filter(n => n.level === 0);\n\tfor (let [index, node] of previous.entries()) {\n\t\tnode.order = index;\n\t}\n\n\twhile (true) {\n\t\tlevel++;\n\t\tlet layer = nodes.filter(n => n.level === level);\n\n\t\tif (layer.length === 0) break;\n\t\tif (layer.length === 1) {\n\t\t\tlayer[0].order = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//  Calculate all preferred node positions as average of parent positions\n\t\tlet order = new Map();\n\t\tfor (let node of layer) {\n\t\t\tlet sum = node.parents.reduce((s, p) => (s += p.order), 0);\n\t\t\tlet avg = sum / node.parents.length;\n\t\t\torder.set(node, avg);\n\t\t}\n\n\t\t// Calculate all parent edge arrays\n\t\tlet edges = new Map();\n\t\tfor (let node of layer) {\n\t\t\tedges.set(node, node.parents.map(p => previous.indexOf(p)));\n\t\t}\n\n\t\t// Sort the layer according to the calculated positions\n\t\tlayer = layer.sort((a, b) => order.get(a) - order.get(b));\n\n\t\t// Bubble sort the layer to minimize edge crossings\n\t\tlet finished = false;\n\t\twhile (!finished) {\n\t\t\tfinished = true;\n\t\t\tfor (let i = 0; i <= layer.length - 2; ++i) {\n\t\t\t\tlet edgesA = edges.get(layer[i]);\n\t\t\t\tlet edgesB = edges.get(layer[i + 1]);\n\t\t\t\tlet swap = shouldSwap(edgesA, edgesB);\n\t\t\t\tif (swap) {\n\t\t\t\t\tfinished = false;\n\t\t\t\t\t[layer[i], layer[i + 1]] = [layer[i + 1], layer[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let [index, node] of layer.entries()) {\n\t\t\tnode.order = index;\n\t\t}\n\n\t\tprevious = layer;\n\t}\n}\n","// Assigns a level to all nodes depending on the horizontal order in the graph\n// A node moves it child nodes to a level + 1, parent nodes can not receive a levelup based on the level of it's child node.\nexport default function(graph) {\n\tfor (let node of graph.values()) {\n\t\tif (node.parents.length === 0) {\n\t\t\tsetLevel(node, 0);\n\t\t}\n\t}\n\n\tfunction setLevel(node, level, skip = []) {\n\t\tnode.level = level;\n\t\tfor (let child of node.children) {\n\t\t\tif (skip.includes(child)) continue;\n\t\t\tif (child.level == undefined || child.level < level + 1) {\n\t\t\t\tsetLevel(child, level + 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\n\t\tfor (let parent of node.parents) {\n\t\t\tif (skip.includes(parent)) continue;\n\t\t\tif (parent.level == undefined) {\n\t\t\t\tsetLevel(parent, level - 1, [...skip, node]);\n\t\t\t}\n\t\t}\n\t}\n}\n","import shift from './shift';\nimport balance from './balance';\nimport topology from './topology';\nimport minimize from './minimize';\nimport normalize from './normalize';\nimport calculateOrder from './calculate-order';\nimport calculateLevel from './calculate-level';\n\nexport default function(nodes, fns) {\n\tlet { childrenFunc, parentFunc, dummyFunc } = fns;\n\n\tlet graph = topology(nodes, { childrenFunc, parentFunc });\n\n\tminimize(graph);\n\tcalculateLevel(graph);\n\tnormalize(graph, dummyFunc);\n\tcalculateOrder(graph);\n\tbalance(graph);\n\tshift(graph);\n\n\treturn graph;\n}\n"],"names":["graph","nodes","Array","from","values","interval","reduce","min","max","node","Math","y","minY","maxY","center","FORCE","MIN_DISTANCE","iterations","previous","Map","order","x","level","i","velocities","oldY","get","undefined","set","gradients","layer","filter","n","sort","a","b","length","neighbour","children","parents","force","blockIndex","blockBound","Infinity","target","block","slice","average","g","gradient","ancestors","parent","includes","push","ancestor","descendents","child","descendent","fns","childFunc","parentFunc","Error","topology","key","value","nodeT","entries","parentT","parentsibling","splice","indexOf","dummyFunc","distance","prev","shouldSwap","edges1","edges2","balance","j","sign","index","avg","s","p","edges","map","finished","setLevel","skip","childrenFunc","minimize","calculateLevel","normalize","calculateOrder","shift"],"mappings":"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"}